## C语言标准和一些关键字的使用

### extern
extern用来扩展C变量和函数的可见性。首先需要说明下变量和函数的声明和定义。  
- 声明只是表明在程序中的某个地方存在变量或函数，但是并没有给它们分配内存。  
- 定义变量或函数的时候，除了声明，同时也给变量或函数分配了内存。所以，可以声明很多次，但是只能定义一次。
- C函数的声明和定义默认带有extern。也就是说即使我们声明和定义C函数时没有使用extern，它也存在。
- 声明一个变量，但是不定义（不分配内存），应该使用extern int var;这种方式。 
- 定义一个变量（分配内存），应该使用int var; 同时声明和定义了一个变量，定义是声明的超集。  
- 声明的同时定义一个变量，extern int var = 3;但是GCC会给警告。
- 对于一些编译器（实际上很多，本地测试使用过gcc和tcc）会使用所谓的'common'定义来定义全局变量。'Common'是指Fortran使用的一种在多个源文件中使用COMMON块共享变量的一种技术。每个源文件提供一个不确定的变量定义，只要不超过一个文件提供初始化定义，那么这些文件最终就会分享一个公共的单一变量定义。也就是说可以直接在header中定义为全局变量，从标准来说，这样会导致多次定义，但是从实际上来说，根据上面的common说明，可以编译通过。见：https://stackoverflow.com/questions/1433204/how-do-i-use-extern-to-share-variables-between-source-files。
- 需要注意的是，被引用的变量的链接属性必须是外链接（external）的，也就是说要引用到var，不只是取决于声明extern int var，还取决于变量var本身是能够被引用到的。能够被其他模块以extern修饰符引用到的变量通常是全局变量。  
- 基本上来说，C文件中要使用别的地方的函数或变量，应该通过引入函数或者变量的声明的方式。函数和变量的定义可以由连接程序去找到。根据惯例，在header中，声明extern int var; 在某一个c文件中，使用int var来进行定义这种方式来使用。 其他源文件在使用extern变量的时候，可以通过引用header的方式，也可以直接通过extern int var声明的方式来使用。

### 全局变量

全局变量是定义在任何函数之外的变量。  
- 全局变量是分配在程序的数据段上而不是在栈上。
- 全局变量(使用extern)可以被所有的函数使用。
- 如果在全局变量前面使用static修饰符，那么该变量只能被同一个文件中的函数访问。
- 全局变量会被自动初始化，局部变量不会自动初始化。初始化一个全局变量或static变量时，只能用常量赋值，不能用变量赋值

### 特殊浮点数
注意不能使用整数0。

    R_Zero = 0.0;
    R_PosInf = 1.0/R_Zero; //打印inf
    R_NegInf = -1.0/R_Zero; //打印-inf
    R_Nan = R_Zero/R_Zero; //打印nan

### 零长数组
- 可以声明长度为零的数组，但它只能被用于结构体的最后一个成员。
- 在sizeof(结构体的时候)，零长数组的长度不计算在内。  
- 此结构体的变长数组只能在函数外定义和初始化，否则会报错error: non-static initialization of a flexible array member。
- 如果要在函数内使用，那么可以定义，但是不能初始化。可以在初始化的时候先初始化非变长数组部分，然后再给变长数组进行赋值，但是这样很可能会报错*** stack smashing detected ***: <unknown> terminated。
- 还是应该提前计算所需的内存大小，然后通过malloc来分配内存，这样才能保证没有问题。

### 内存对齐和填充 参考 http://www.catb.org/esr/structure-packing/上
- 对齐要求 (Alignment requirements)
首先要理解的是，在现代处理器上，为了使内存访问更快，编译器在内存中放置基本数据类型的方式是受限的。   
在x86和ARM处理器上存储基本C数据类型不是从内存中的任意字节地址开始的。实际上，除了char类型，所有类型都有对齐要求；char可以从任意字节地址开始，但是2字节short必须从一个偶数地址开始，
4字节int或者float，必须从4的整数倍地址开始，8字节long或者double必须从8的整数倍地址开始。有符号和无符号都是一样的。指针，不管是32-bit(4字节)还是64-bit(8字节)都是自对齐的。  
用行话来说，在x86和ARM上基本C类型是自对齐的。自对齐使获取和设置特定类型数据只需要一条指令，所以会使内存访问更快。另一方面，如果没有对齐限制，则代码最后可能会不得不跨越机器字边界进行两次或者多次访问。字符是一个特殊情况，在一个机器字中，无论从哪里访问代价都是一样的。这也是为什么它们不需要对齐。    
- 填充(Padding)
连续声明的变量中间可能会进行填充以满足对齐要求。  
在一个有对齐类型的平台上，char/short/int/long/pointer数组没有内部padding，每个成员都是自动对齐。  
- 结构体对齐和填充
    - 通常一个结构体实例使用它的最宽的标量成员来进行对齐。编译器使用这种最简单的方式以确保所有的成员都是自对齐的。  
    - 同时，在C（还有Go和Rust）中，结构体的地址就是它的第一个成员的地址，在前面没有填充。请注意：在C++中看起来像结构体的类可能会破坏这一规则。（是否会这样，取决于基类和虚函数是如何实现的，而这些实现在不同的编译器中并不相同。） ANSI C提供了一个offsetof()可以用来读取结构体成员的偏移量。不过offsetof()不能作用于位域。 
    - 编译器表现的就像结构体有尾填充,尾填充会直到在结构体数据之后和结构体有着相同对齐大小的第一个地址。这条规则控制着sizeof()会返回的数值。例如结构体是8字节对齐的，那么尾填充就会到结构体本身数据之后第一个8的倍数的地址，sizeof()也会是8的整数。
    - 如果一个结构体有结构体成员，那么内部的结构体仍然是按照最长的标量对齐。
- 位域  Bitfields
位域可以声明比一个字符宽度更小的结构体成员，最少为1bit。  
关于位域需要知道的是，它们是由字和字节级别的掩码及操作机器字的旋转指令实现的，并且不能跨越字的边界。另外需要注意的是，int t:1这样的声明并不是说t要占用一个int类型的大小，实际其只占用1bit。至于什么时候填充及是否填充，要看其前后成员的大小会不会导致跨越字的边界，从测试结果来看字的大小似乎是4。根据实际测试，位域不影响结构体成员的填充；但是会影响尾填充，如果位域的类型是所有类型中最大的，那么最终struct的大小要是该类型大小的整数倍。例如
        struct foo3 {
                char a;
                short b; //offset 2,表明a是按照最大2字节对齐
                int c:1;
                int d:3;
                char e; //offset 5
                char f;
                short g;// offset 8
        }; // size 12
        struct foo4 {
                char a;
                short b; //offset 2,表明a是按照最大2字节对齐
                long c:1;
                long d:3;
                char e; //offset 5
                char f;
                short g;// offset 8
        }; // size 16
        struct foo5 {
                char a;
                short b; //offset 2,表明a是按照最大2字节对齐
                int c:17;
                int d:17;
                char e; // offset 11,表明b、c和d共占用了9字节，已知b占用2字节，也就是说c的起始在4字节的倍数，因为c+d超过了字的边界4字节，所以c占用4字节。这样d的起始也在4字节的倍数，但是d+e小于4字节，没有超过4的边界，e占1字节，所以d占3字节。
                char f;
        }; // size 16

具体使用的时候还是应该仔细测试一下，以确保没有问题。
- 结构体重排序
知道了何时结构体内部和结构体尾部会进行填充，现在我们要看一下如何能够减少这些padding以节省内存。  
最简单的减少填充的方法是按照对齐大小倒序排列结构体成员。也就是说先放指针，然后放int，然后是short，最后是char。
- 一些要要注意的标量情况
enums虽然能保证和整型兼容，但是标准并没有指出具体哪一种整型。 long double类型在不同平台上的大小也可能不一样，可能是80bit，96bit，128bit等。
在x86下 Linux double有时候并不遵守对齐规则；一个8字节的double在结构体内可能只要求4字节的对齐，虽然独立的double变量要求8字节对齐。这取决于编译器和编译器的一些选项。  
尽量还是使用sizeof以确保没有问题。
- 可读性和缓存本地性
调整成员顺序可能会影响可读性，因为同组的成员可能会被分开。当你的程序经常访问一个结构体或者结构体的一部分时，如果访问都能保持在一条cache line（处理器获取任何单一地址的内存时需要获取到的整个内存块）中，那么会提升性能。在64位的x86平台上，一个cache line是一个从自对齐的地址开始的64字节；在其他平台上，通常是32字节。
如果进行需要对线程并发访问结构体，会遇到一个问题：cache line bouncing。为了最小化昂贵的总线流量，应该调整数据以使从一个cache line读，而从另一个cahce line写。

- 其他打包技术
如果有多个布尔标记位，那么可以考虑使用1bit的位域来代替。 尽量使用小的数据类型。 最危险的方法是使用union。

- 撤销对齐规则
有时可以强制不使用处理器的对齐规则，通常是通过使用 #pragma pack。 GCC可以使用__attribute__((__packed__))来声明结构体；GCC有一个针对整个编译的选项-fpack-struct.  
使用#pragma pack的唯一好的理由是，你必须使C数据布局和某些比特基本的硬件或者协议匹配，例如一个内存映射的硬件端口。